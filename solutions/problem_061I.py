'''https://projecteuler.net/problem=61
Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are
all figurate (polygonal) numbers and are generated by the following formulae:

Triangle    P3(n) = n(n + 1)/2      1, 3, 6, 10, 15, ...
Square      P4(n) = n^2             1, 4, 9, 16, 25,...
Pentagonal  P5(n) = n(3n - 1)/2     1, 5, 12, 22, 35,...
Hexagonal   P6(n) = n(2n - 1)       1, 6, 15, 28, 45,...
Heptagonal  P7(n) = n(5n - 3)/2     1, 7, 18, 34, 55,...
Octagonal   P8(n) = n(3n - 2)       1, 8, 21, 40, 65,...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
interesting properties.
    1. The set is cyclic, in that the last two digits of each number is the
    first two digits of the next number (including the las number with the
    first).
    2. Each polygonal type: triangle (P3(127) = 8128), square (P4(91) = 8281),
    and pentagonal (P5(44) = 2882), is represented by a different number in
    the set.
    3. This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which
each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and
octagonal, is represented by a different number in the set.
'''
from resources.useful_functions import (
    is_triangle, is_square, is_pentagonal, is_hexagonal, is_heptagonal,
    is_octagonal)


class PolyNum:
    '''Class representing a number and the figures it can represent.'''
    def __init__(self, n):
        # Number
        self.n = n
        # Figures that the number can represent
        self.figs = self._get_figs(self.n)

    def _get_figs(self, n):
        '''Returns a list with each figure that the number can represent.'''
        figures = []
        if is_triangle(n):
            figures.append('Triangle')
        if is_square(n):
            figures.append('Square')
        if is_pentagonal(n):
            figures.append('Pentagon')
        if is_hexagonal(n):
            figures.append('Hexagon')
        if is_heptagonal(n):
            figures.append('Heptagon')
        if is_octagonal(n):
            figures.append('Octagon')
        return figures


def find_cyclic_nums():
    def fig_start(start):
        '''Returns the 4-digit figurate PolyNums that begin with start.'''
        return [N for N in figurate_nums
                if N.n//100 == start]

    def recursive_helper(current, start, missing):
        # There are still figurate numbers missing
        if missing:
            # For each figurate number that begins with start
            for N in fig_start(start):
                # For each figure for the current number
                for fig in N.figs:
                    # If the figure is missing
                    if fig in missing:
                        n = N.n
                        # We calculate the start for the following number
                        start = n % 100
                        # and remove the figure from the missing list
                        new_missing = [f for f in missing if f != fig]
                        # We also add the current num to the list
                        sol = recursive_helper(current+[n], start, new_missing)
                        # If a solution was found, bring it to the top
                        if sol:
                            return sol
        # No more figures missing! Does the cycle close?
        elif current[0]//100 == start:
            return current
        # No solution was found in this recursion
        return False

    # Excluding numbers which their tens unit is 0, because in that case we
    # would cycle with a 3-digit number
    poly_four_digs = [PolyNum(n) for n in range(1000, 10000) if n % 100 >= 10]
    # List of all the numbers that are figurate (triangular to octagonal)
    figurate_nums = [N for N in poly_four_digs if len(N.figs) > 0]

    # We start with the octagonal numbers
    octagonal = [Num for Num in figurate_nums if 'Octagon' in Num.figs]
    # The remaining figures to look for
    figures = ['Heptagon', 'Hexagon', 'Pentagon', 'Square', 'Triangle']
    for Num in octagonal:
        n = Num.n
        start = n % 100
        cyclic = recursive_helper([n], start, figures)
        if cyclic:
            return cyclic


if __name__ == '__main__':
    print(find_cyclic_nums())  # 28684, 0.014s
