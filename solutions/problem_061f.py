'''https://projecteuler.net/problem=61'''
# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers
# are all figurate (polygonal) numbers and are generated by the following
# formulae:

# Triangle    P3(n) = n(n + 1)/2      1, 3, 6, 10, 15, ...
# Square      P4(n) = n^2             1, 4, 9, 16, 25,...
# Pentagonal  P5(n) = n(3n - 1)/2     1, 5, 12, 22, 35,...
# Hexagonal   P6(n) = n(2n - 1)       1, 6, 15, 28, 45,...
# Heptagonal  P7(n) = n(5n - 3)/2     1, 7, 18, 34, 55,...
# Octagonal   P8(n) = n(3n - 2)       1, 8, 21, 40, 65,...

# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
# interesting properties.
#     1. The set is cyclic, in that the last two digits of each number is the
#     first two digits of the next number (including the las number with the
#     first).
#     2. Each polygonal type: triangle (P3(127) = 8128), square
#     (P4(91) = 8281), and pentagonal (P5(44) = 2882), is represented by a
#     different number in the set.
#     3. This is the only set of 4-digit numbers with this property.

# Find the sum of the only ordered set of six cyclic 4-digit numbers for which
# each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and
# octagonal, is represented by a different number in the set.
from resources.useful_functions import (
    is_triangle, is_square, is_pentagonal, is_hexagonal, is_heptagonal,
    is_octagonal)


def get_figs(n):
    '''Returns a list with each figure that the number n can represent.'''
    figures = []
    if is_triangle(n):
        figures.append('Triangle')
    if is_square(n):
        figures.append('Square')
    if is_pentagonal(n):
        figures.append('Pentagon')
    if is_hexagonal(n):
        figures.append('Hexagon')
    if is_heptagonal(n):
        figures.append('Heptagon')
    if is_octagonal(n):
        figures.append('Octagon')
    return figures


def find_cyclic_nums():
    '''Finds the only ordered set of six cyclic 4-digits numbers described in
    the problem statement.'''
    def fig_start(start):
        '''Returns the 4-digit figurate nums that begin with start.'''
        return [n for n in figurate_nums if n//100 == start]

    def recursive_helper(current, start, missing):
        # There are still figurate numbers missing
        if missing:
            # For each figurate number that begins with start
            for n in fig_start(start):
                # For each figure for the current number
                for fig in figurate_nums[n]:
                    # If the figure is missing
                    if fig in missing:
                        # We calculate the start for the following number
                        start = n % 100
                        # and remove the figure from the missing list
                        new_missing = [f for f in missing if f != fig]
                        # We also add the current num to the list
                        sol = recursive_helper(current+[n], start, new_missing)
                        # If a solution was found, bring it to the top
                        if sol:
                            return sol
        # No more figures missing! Does the cycle close?
        elif current[0]//100 == start:
            return current
        # No solution was found in this recursion
        return False

    # Excluding numbers which their tens unit is 0, because in that case we
    # would cycle with a 3-digit number
    four_digs = [n for n in range(10**3, 10**4) if n % 100 >= 10]
    # List of all the numbers that are figurate (triangular to octagonal)
    figurate_nums = {n: get_figs(n) for n in four_digs if len(get_figs(n)) > 0}

    # We start with the octagonal numbers
    octagonal = [n for n in figurate_nums if 'Octagon' in figurate_nums[n]]
    # The remaining figures to look for
    figures = ['Heptagon', 'Hexagon', 'Pentagon', 'Square', 'Triangle']
    for oc in octagonal:
        start = oc % 100
        cyclic = recursive_helper([oc], start, figures)
        if cyclic:
            return cyclic


if __name__ == '__main__':
    print(find_cyclic_nums())  # 28684, 0.014s
